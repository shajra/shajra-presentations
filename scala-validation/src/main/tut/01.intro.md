% Validation with Functional Programming
% Sukant Hajra / @shajra
% April 14, 2016

## Some Goals

- use type classes to get nice APIs (DSLs)
- explore data structures for managing errors
- see some examples with parsing

## Introducing scalaz.\\/

```tut
import scalaz.syntax.either._

1.right[String]

"fail".left[Int]
```

## Syntax with \\/

```tut
1.right[String].flatMap { a =>
  2.right[String].map { b =>
    a + b
  }
}

for { a <- 1.right[String]; b <- 2.right[String] }
yield a + b

import scalaz.syntax.apply._

1.right[String] |@| 2.right[String] apply { _ + _ }
```

## Failures with \\/

```tut
(1.right[String] |@| 2.right[String]).
  apply { _ + _ }

(1.right[String] |@| "fail 2".left[Int]).
  apply { _ + _ }

("fail 1".left[Int] |@| 2.right[String]).
  apply { _ + _ }

("fail 1".left[Int] |@| "fail 2".left[Int]).
  apply { _ + _ }
```

## Introducing scalaz.ValidationNel

```tut
import scalaz.syntax.validation._

1.success[String]

"fail".failure[Int]

1.successNel[String]

"fail".failureNel[Int]
```

## Failures with ValidationNel

```tut
(1.successNel[String] |@| 2.successNel[String]).
  apply { _ + _ }

(1.successNel[String] |@| "fail 2".failureNel[Int]).
  apply { _ + _ }

("fail 1".failureNel[Int] |@| 2.successNel[String]).
  apply { _ + _ }

("fail 1".failureNel[Int] |@| "fail 2".failureNel[Int]).
  apply { _ + _ }
```

## Dangerous flatMap on ValidationNel

```tut
1.success[String].flatMap { a =>
  2.success[String].map { b =>
    a + b
  }
}
```

## What more is possible?

### Example API

```scala
case class UserData(name: String, dob: Option[Date])

def sub(key: String): JsonParser[Json] = ???
def required[A : JsonParse](key: String): JsonParser[A] = ???
def lookup[A : JsonParse](key: String): JsonParser[Option[A]] =
  ???

val userParser: JsonParser[UserData] =
  (required[String]("name") |@| lookup[Date]("dob")).
    apply(UserData)

def result(json: Json): ValidationNel[ParseFault, UserData] =
  (userParser |@| (sub("friend") >>> userParser)).
    tupled.read(json)
```
