% MTL: Less is More
  (a.k.a. Stop Eff'ing)
% Sukant Hajra / @shajra
% March 24, 2017

## Quick mention

![My Employer](images/cogscale.jpg)

## Materials

### This presentation and all code can  be found at

http://github.com/shajra/shajra-presentations/scala-mtl

## Meta-conversation

### Some disclaimers

- Please pardon the sensationalism.
- I have no panacea.

### Let's be careful about

- false technical ladders
- abstraction boredom
- abstraction tribalism.

## In lieu of time

### Assuming knowledge of

- Scala implicits
- type classes
- for-yield sugar w.r.t. `Monad`.

## Monads, Explicitly

###

```tut:silent
trait Monad[M[_]] {

  def pure[A](a: A): M[A]

  def flatMap[A, B](ma: M[A])(f: A => M[B]): M[B] =
    flatten(map(ma)(f))

  def map[A, B](ma: M[A])(f: A => B): M[B] =
    flatMap(ma)(f andThen pure)

  def flatten[A](mma: M[M[A]]): M[A] =
    flatMap(mma)(identity)

}

def Monad[M[_] : Monad]: Monad[M] = implicitly[Monad[M]]
```

### Note: the `Monad` type class has three laws

very important, but elided for time

## Monad syntax with implicits

### For convenience (e.g. with for-yield)

```tut:silent
implicit class OpsA[A](a: A) {

  def pure[M[_]](implicit M: Monad[M]): M[A] =
      M pure a

}

implicit class MonadOps[M[_], A](ma: M[A])(implicit M: Monad[M]) {

  def map[B](f: A => B): M[B] =
    M.map(ma)(f)

  def flatMap[B](f: A => M[B]): M[B] =
    M.flatMap(ma)(f)

}
```

# Motivation

## Where people come from

### Enterprise Java

```scala
trait DbConn; trait MetricsConn

class UsersDao @Inject() (db: DbConn)

class InsightsDao @Inject() (db: DbConn, metrics: MetricsConn)

class App @Inject() (users: UsersDao, insights: InsightsDao)
```

### Complaints

- no compile-time safety
- lacks composition with other FP practices

## A first response

### Have you tried passing a parameter to a function?

```tut:silent
trait DbConn; trait MetricsConn

case class User(name: String)
case class Insight(desc: String)

def newUser(db: DbConn)(name: String): User = ???

def getInsight
    (db: DbConn, metrics: MetricsConn)(user: User)
    : Insight = ???

def runApp(db: DbConn, metrics: MetricsConn): App = ???
```

### Observations

- safer (no runtime reflection)
- feels like "manual" dependency injection

## A second response

### Passing a parameter is just the "Reader" monad

```tut:silent
case class Reader[R, A](run: R => A)

implicit def readerMonad[R]: Monad[Reader[R, ?]] =
  new Monad[Reader[R, ?]] {
    def pure[A](a: A): Reader[R, A] =
      Reader { _ => a }
    override def flatMap[A, B]
        (ra: Reader[R, A])(f: A => Reader[R, B]): Reader[R, B] =
      Reader { r => f(ra run r) run r }
  }
```

## A second response

###

```tut:silent
trait DbConfig; trait MetricsConfig

case class AppConfig(db: DbConfig, metrics: MetricsConfig)

def newUser(name: String): Reader[AppConfig, User] = ???

def getInsight(user: User): Reader[AppConfig, Insight] = ???

def app: Reader[AppConfig, Insight] =
  for {
    u <- newUser("Sukant")
    i <- getInsight(u)
  } yield i
```

## A second response

### Benefits

- Plumbing is hidden a little.
- We're getting some composition.

### Complaints

- A global config is anti-modular.
- Side-effects! Is this even FP?


## Effect-tracking types

### No side-effects (but blows stack)

```tut:silent
class IO[A](a: => A) {
  def unsafeRun: A = a
}

object IO { def apply[A](a: => A) = new IO(a) }

implicit def ioMonad: Monad[IO] =
  new Monad[IO] {
    def pure[A](a: A): IO[A] = IO(a)
    override def flatMap[A, B]
        (ioa: IO[A])(f: A => IO[B]): IO[B] =
      IO(f(ioa.unsafeRun).unsafeRun)
  }
```

## Effect-tracking types

### No side-effects while composing

```tut:silent
def getTime: IO[Long] = IO { System.currentTimeMillis }
def printOut[A](a: A): IO[Unit] = IO { println(a) }

def sillyIO: IO[Unit] =
  for {
    t <- getTime
    _ <- printOut(t)
    _ <- printOut(t)
  } yield ()
```

### Run at the "end of the world"

```tut
sillyIO.unsafeRun
```

## In general, monads don't compose

### We can't implement this

```tut:silent
case class Compose[F[_], G[_], A](fga: F[G[A]])

def impossible[F[_] : Monad, G[_] : Monad]
    : Monad[Compose[F, G, ?]] = ???
```

### Question

Can we compose `IO` and `Reader` specifically?

### Answer

Yes, that's exactly what monad transformers do.

## Many monads have respective transformers

### `Reader`'s transformer --- `ReaderT`

```tut:silent
case class ReaderT[R, M[_], A](run: R => M[A])

implicit def readerTMonad[R, M[_]]
    (implicit M: Monad[M]): Monad[ReaderT[R, M, ?]] =

  new Monad[ReaderT[R, M, ?]] {

    def pure[A](a: A): ReaderT[R, M, A] =
      ReaderT { _ => M.pure(a) }

    override def flatMap[A, B]
        (ma: ReaderT[R, M, A])(f: A => ReaderT[R, M, B])
        : ReaderT[R, M, B] =
      ReaderT { r => M.flatMap(ma run r) { f(_) run r } }

  }
```

## A useful typeclass for readers

###

```tut:silent
trait MonadReader[R, M[_]] {
  def monad: Monad[M]
  def ask: M[R]
}

object MonadReader {
  def ask[F[_], R](implicit F: MonadReader[R, F]): F[R] =
    F.ask
}
```

## Creating `MonadReader` for `ReaderT`

```tut:silent
implicit def readerTMonadReader[R, F[_]]
    (implicit F: Monad[F])
    : MonadReader[R, ReaderT[R, F, ?]] =
  new MonadReader[R, ReaderT[R, F, ?]] {
    val monad = readerTMonad(F)
    def ask: ReaderT[R, F, R] = ReaderT { _.pure[F] }
  }
```

## We can create "stacked" monads

### Composing a monad stack

```tut:silent
type Stack[A] = ReaderT[Int, IO, A]

val example1: Stack[Int] =
  for {
    r <- MonadReader.ask[Stack, Int]
    c <- 1.pure[Stack]
  } yield r + c
```

### Running a monad stack

```tut
example1.run(2).unsafeRun
```

## Observations

### Improvements
- separations of concerns (Reader from IO)
- no side-effects

### Remaining Complaint
- still using a global configuration
