% MTL: Less is More
  (a.k.a. Stop Eff'ing)
% Sukant Hajra / @shajra
% March 24, 2017

## Quick mention

![My Employer](images/cogscale.jpg)

## Materials

### This presentation and all code is

- at http://github.com/shajra/shajra-presentations/scala-mtl
- compiler-checked by Rob Norris's `sbt-tut` plugin.

## Meta-conversation

### Some disclaimers

- Please pardon the sensationalism.
- I have no panacea.

### Let's be careful about

- false technical ladders
- abstraction boredom
- abstraction tribalism
- vestigial technical debt.

## In lieu of time

### Assuming knowledge of

- Scala implicits
- type classes
- for-yield sugar w.r.t. `Monad`.

## Monads, Explicitly

###

```tut:silent
trait Monad[M[_]] {

  def pure[A](a: A): M[A]

  def flatMap[A, B](ma: M[A])(f: A => M[B]): M[B] =
    flatten(map(ma)(f))

  def map[A, B](ma: M[A])(f: A => B): M[B] =
    flatMap(ma)(f andThen pure)

  def flatten[A](mma: M[M[A]]): M[A] =
    flatMap(mma)(identity)

}
```

### Note: the `Monad` type class has three laws

very important, but elided for time

## Monad syntax with implicits

### For convenience (e.g. with for-yield)

```tut:silent
implicit class OpsA[A](a: A) {

  def pure[M[_]](implicit M: Monad[M]): M[A] =
      M pure a

}

implicit class
    MonadOps[M[_], A](ma: M[A])(implicit M: Monad[M]) {

  def map[B](f: A => B): M[B] =
    M.map(ma)(f)

  def flatMap[B](f: A => M[B]): M[B] =
    M.flatMap(ma)(f)

}
```

# Towards Transformers

## Where people come from

### Enterprise Java

```scala
trait DbConn; trait MetricsConn

class UsersDao @Inject() (db: DbConn)

class InsightsDao @Inject() (db: DbConn, metrics: MetricsConn)

class App @Inject() (users: UsersDao, insights: InsightsDao)
```

### Complaints

- no compile-time safety
- lacks composition with other FP practices

## A first response

### Have you tried passing a parameter to a function?

```tut:silent
trait DbConn; trait MetricsConn

case class User(name: String)
case class Insight(desc: String)

def newUser(db: DbConn)(name: String): User = ???

def getInsight
    (db: DbConn, metrics: MetricsConn)(user: User)
    : Insight = ???

def runApp(db: DbConn, metrics: MetricsConn): App = ???
```

### Observations

- safer (no runtime reflection)
- feels like "manual" dependency injection

## A second response

### Passing a parameter is just the "reader" monad

```tut:silent
case class Reader[R, A](run: R => A)
```

## A second response

### `Reader`'s monad instance

```tut:silent
implicit def readerMonad[R]: Monad[Reader[R, ?]] =
  new Monad[Reader[R, ?]] {

    def pure[A](a: A): Reader[R, A] =
      Reader { _ => a }

    override def flatMap[A, B]
        (ra: Reader[R, A])(f: A => Reader[R, B])
        : Reader[R, B] =
      Reader { r => f(ra run r) run r }

  }
```

## A second response

###

```tut:silent
trait DbConfig; trait MetricsConfig

case class AppConfig(db: DbConfig, metrics: MetricsConfig)

def newUser(name: String): Reader[AppConfig, User] = ???

def getInsight(user: User): Reader[AppConfig, Insight] = ???

def app: Reader[AppConfig, Insight] =
  for {
    u <- newUser("Sukant")
    i <- getInsight(u)
  } yield i
```

## A second response

### Benefits

- Plumbing is hidden a little.
- We're getting some composition.

### Complaints

- A global config is anti-modular.
- Side-effects! Is this even FP?


## Effect-tracking types

### Naive implementation for presentation (stack unsafe)

```tut:silent
class IO[A](a: => A) {
  def unsafeRun: A = a
}

object IO { def apply[A](a: => A) = new IO(a) }

implicit def ioMonad: Monad[IO] =
  new Monad[IO] {
    def pure[A](a: A): IO[A] = IO(a)
    override def flatMap[A, B]
        (ioa: IO[A])(f: A => IO[B]): IO[B] =
      IO(f(ioa.unsafeRun).unsafeRun)
  }
```

## Effect-tracking types

### No side-effects while composing

```tut:silent
def getTime: IO[Long] = IO { System.currentTimeMillis }
def printOut[A](a: A): IO[Unit] = IO { println(a) }

def sillyIO: IO[Unit] =
  for {
    t <- getTime
    _ <- printOut(t)
    _ <- printOut(t)
  } yield ()
```

### Run at the "end of the world"

```tut
sillyIO.unsafeRun
```

## Let's compose our monads

### But in general, monads don't compose

```tut:silent
case class Compose[F[_], G[_], A](fga: F[G[A]])

def impossible[F[_] : Monad, G[_] : Monad]
    : Monad[Compose[F, G, ?]] = ???
```

### Question

Can we compose `IO` and `Reader` specifically?

### Answer

Yes, that's exactly what monad transformers do.

## Many monads have respective transformers

### `Reader`'s transformer --- `ReaderT`

```tut:silent
case class ReaderT[R, M[_], A](run: R => M[A])
```

## `ReaderT`'s monad instance

### Depends on inner type's monad instance

```tut:silent
implicit def readerTMonad[R, M[_]]
    (implicit M: Monad[M]): Monad[ReaderT[R, M, ?]] =

  new Monad[ReaderT[R, M, ?]] {

    def pure[A](a: A): ReaderT[R, M, A] =
      ReaderT { _ => M.pure(a) }

    override def flatMap[A, B]
        (ma: ReaderT[R, M, A])(f: A => ReaderT[R, M, B])
        : ReaderT[R, M, B] =
      ReaderT { r => M.flatMap(ma run r) { f(_) run r } }

  }
```

## We can create "stacked" monads

### Composing a monad stack

```tut:silent
type Stack[A] = ReaderT[Int, IO, A]

val example1: Stack[Int] =
  for {
    r <- ReaderT { (_: Int).pure[IO] }  // ugly
    c <- 1.pure[Stack]
  } yield r + c
```

### Running a monad stack

```tut
example1.run(2).unsafeRun
```

## A useful typeclass for readers

###

```tut:silent
trait MonadReader[R, M[_]] {
  def monad: Monad[M]
  def ask: M[R]
  def local[A](ma: M[A])(f: R => R): M[A]
}

object MonadReader {
  def ask[M[_], R](implicit MR: MonadReader[R, M]): M[R] =
    MR.ask
}
```

### Note: the `MonadReader` type class has laws

very important, but elided for time

## Creating `MonadReader` for `ReaderT`

###

```tut:silent
implicit def readerTMonadReader[R, M[_]]
    (implicit M: Monad[M])
    : MonadReader[R, ReaderT[R, M, ?]] =
  new MonadReader[R, ReaderT[R, M, ?]] {

    val monad = readerTMonad(M)

    def ask: ReaderT[R, M, R] = ReaderT { _.pure[M] }

    def local[A]
        (ma: ReaderT[R, M, A])(f: R => R): ReaderT[R, M, A] =
      ReaderT { ma run f(_) }

  }
```

## More polymorphism

### Stack not specified, only constrained

```tut:silent
def example2[M[_] : Monad : MonadReader[Int, ?[_]]]: M[Int] =
  for {
    r <- MonadReader.ask[M, Int]
    c <- 1.pure[M]
  } yield r + c
```

### Stack specified when run

```tut
example2[Stack].run(2).unsafeRun
```

## Many other transformers

Transformer             | Underlying            | Type class
------------------------|-----------------------|-----------------------
`IdentityT[M[_], A]`    | `M[A]`                |
`ReaderT[S, M[_], A]`   | `R => M[A]`           | `MonadReader[R, M[_]]`
`StateT[S, M[_], A]`    | `S => M[(S, A)]`      | `MonadState[S, M[_]]`
`OptionT[M[_], A]`      | `M[Option[A]]`        | `MonadOption[E, M[_]]`
`EitherT[E, M[_], A]`   | `M[Either[E,A]]`      | `MonadError[E, M[_]]`
`ContT[M[_], A]`        | `(A => M[R]) => M[R]` | `MonadCont[M[_]]`
...                     | ...                   | ...

## Some transformers commute effects

### But we end up with $O(n^2)$ to support them

```tut:invisible
trait MonadError[E, M[_]]
trait MonadState[S, M[_]]
trait ContT[M[_], A]
```

```tut:silent
implicit def readerTMonadState[R, S, M[_]]
    (implicit MS: MonadState[S, M])
    : MonadState[S, ReaderT[R, M, ?]] =
  ???  // can be implemented lawfully
```

### Not all transformers commute effects

```tut:silent
implicit def contTMonadError[R, E, M[_]]
    (implicit ME: MonadError[E, M])
    : MonadError[E, ContT[M, ?]] =
  ???  // would break MonadError laws if implemented
```

## What about lifting?

### People used to complain about this

```tut:silent
trait MonadTrans[T[_[_], _]] {
  def liftT[G[_] : Monad, A](a: G[A]): T[G, A]
}
```

### But now it can be internal plumbing

- Don't lift too much!
- With the SI-2712 fix, you don't have to

## A useful lift, though

### For lifting your base monad

```tut:silent
trait MonadBase[B[_], M[_]] {
  def monadBase: Monad[B]
  def monad: Monad[M]
  def liftBase[A](base: B[A]): M[A]
}
```

## What have we got thus far?

### Improvements
- separations of concerns (Reader from IO)
- no side-effects

### Remaining Complaint
- still using a global configuration
